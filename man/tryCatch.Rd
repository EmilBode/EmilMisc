% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Fixes-extensions.R
\name{tryCatch}
\alias{tryCatch}
\title{Extension of base::tryCatch}
\usage{
tryCatch(expr, ..., finally)
}
\arguments{
\item{expr}{Expressions to evaluate that might throw an error}

\item{...}{Handlers to call if expr throws a condition}

\item{finally}{expression that is always evaluated before returning or exiting}
}
\description{
The regular \code{\link[base:conditions]{base::tryCatch}} calls a function whenever \code{expr} generates an error, which means this function gets its own environment.
However, sometimes it's easier to evaluate any code in the same environment as \code{expr} (see examples).\cr
Therefore this extension can work with expressions as well, which are then evaluated in the calling context.
If this expression returns a function, then that function is called with the condition-object.
Note that 'expression' here is used in the sense of 'some R-code', so \code{error=function(e) {e$message}} is seen as a very simple expression, which
returns a function, which is then called. This means that you can still use the same calls as in \code{base::tryCatch}.
}
\details{
For use of the condition-object in the main expressions, you can access it under the name "cond" if there is no variable under that name yet.
If there is one, this variable is left as-is, and the current condition-object can be accessed with \code{get('cond', parent.frame(2))}.\cr
The latter form can always be used (for cases when you're unsure of its existence)
}
\note{
All current variables are potentially modified by the condition-throwing expression, which may be very desirable (for debugging) or
very undesirable/confusing (as some objects can be in an unexpected/corrupted state)
}
\section{Note on backwards compatibility}{

This function is meant as a stand-in replacement for base::tryCatch, but there are differences in the calling stack.\cr
See for example the difference in the options you can choose from in the following calls:
\code{base::tryCatch(stop(), error=function(e) recover())}\cr
vs\cr
\code{tryCatch(stop(), error=function(e) recover()}\cr\cr
Therefore there may be some differences in debugging code as well, and code should not rely on any output
of parent.frame(n) or length(sys.calls()) etc.
}

\examples{
errorlog <- character(0) # Or some other previous log
tryCatch({step <- 1;stop('SomeError');step <- 2},
  warning=function(w) print(w),
  error={errorlog <- c(errorlog, paste("\\nError occured:\\n", cond$message, "\\nat step:", step))
         step <- 0
         function(e) {err <- getOption('error'); if(!is.null(err)) eval(err)}
  })

}
