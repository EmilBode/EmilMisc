% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Misc.R
\name{readline_time}
\alias{readline_time}
\title{Readline with waiting limit}
\usage{
readline_time(prompt, timeout = 3600, precision = 0.1)
}
\arguments{
\item{prompt}{prompt for the user, similar to the one in readline(). Usually ends with a space (or newline).}

\item{timeout}{timer in seconds. If set to 0, base::readline is used}

\item{precision}{Polling interval in seconds. \cr
Internally, every \code{precision} seconds the script checks if valid input is received.
Smaller values increase responsiveness, but also increase CPU-usage.}
}
\value{
Input provided by the user, if provided in time (and finished with RETURN)\cr
If the timer has expired, \code{character(0)}, even if the user has started typing but has not yet pressed RETURN.
If used in a non-interactive session, NULL, and if the timer has expired, character(0).\cr
If timeout==0, the same as provided by readline()
}
\description{
Normally, when using readline, execution is halted until input is supplied, and if it is not, the script hangs forever
This functions waits a set time for the user to provide input, then returns control
}
\note{
Unfortunately, does not work on all platforms/in all environments.\cr
It is dependent on being able to read from file('stdin'), which is different from stdin(), see \code{\link[base:connections]{file}} for details.
In particular, it does not work in RStudio for MacOS, or Rgui for Windows or MacOS.
It does confirmed work on R run from terminal on MacOS 10.13.6\cr
Problems manifest by file('stdin') not being connected to anything, i.e. no input is received, so this function always returns \code{character(0)},
and any input typed is interpreted as a new command. To test, try with a small value of timeout first.
}
\seealso{
\code{\link{waitForKey}} for a function that simply waits for a keypress for a set time.
}
